<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dualm的学习笔记</title>
    <link>http://dualm.github.io/post/</link>
    <description>Recent content in Posts on Dualm的学习笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright © Dualm 2019. Generated by Hugo</copyright>
    <lastBuildDate>Wed, 18 Dec 2019 17:06:39 +0800</lastBuildDate>
    
	<atom:link href="http://dualm.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Bytes</title>
      <link>http://dualm.github.io/2019/12/18/bytes/</link>
      <pubDate>Wed, 18 Dec 2019 17:06:39 +0800</pubDate>
      
      <guid>http://dualm.github.io/2019/12/18/bytes/</guid>
      <description>bytes库学习笔记 bytes库主要用于byte类切片的处理。包括内容如下：
 常量：
const MinRead = 512  变量：
var ErrTooLarge = errors.New(&amp;quot;bytes.Buffer: too large&amp;quot;)  类型：
 // 大小可变的bytes数据缓冲，拥有Read和Write方法。零值为空Buffer // type Buffer struct { // buf []byte // contents are the bytes buf[off : len(buf)] // off int // read at &amp;amp;buf[off], write at &amp;amp;buf[len(buf)] // lastRead readOp // last read operation, so that Unread* can work correctly. // } type Buffer  // 增加了Read、Seek方法的byte切片，并且是只读的。零值为操作空切片的Reader // type Reader struct { // s []byte // i int64 // current reading index // prevRune int // index of previous rune; or &amp;lt; 0 // } type Reader   函数：</description>
    </item>
    
    <item>
      <title>表格驱动测试</title>
      <link>http://dualm.github.io/2019/09/16/tabledriventests/</link>
      <pubDate>Mon, 16 Sep 2019 15:47:27 +0800</pubDate>
      
      <guid>http://dualm.github.io/2019/09/16/tabledriventests/</guid>
      <description>简介 编写完善的测试代码是必不可少的，但在大多数情况下可以用表格驱动测试来覆盖许多测试内容：每一个表格的入口都是一个带有输入和期望输出的完整测试用例，并且有时还可以附加一个&amp;rdquo;name&amp;rdquo;信息来方便查看测试输出。当你意识到你通过复制和粘贴来开发测试代码时，考虑一下将测试重构为表格驱动测试，或者将重复代码写入helper函数中，也许是一个更好的替代方案。
设想一个有多个测试用例的表格，实际的测试只是迭代所有的表格入口，并执行必要的测试。测试代码只编写了一次，但可以覆盖所有的表格入口，所以说小心地写一个带有良好错误信息的测试还是有用的。
一个 表格驱动测试的例子 下面这段代码截取自fmt包。 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  var flagtests = []struct { in string out string }{ {&amp;#34;%a&amp;#34;, &amp;#34;[%a]&amp;#34;}, {&amp;#34;%-a&amp;#34;, &amp;#34;[%-a]&amp;#34;}, {&amp;#34;%+a&amp;#34;, &amp;#34;[%+a]&amp;#34;}, {&amp;#34;%#a&amp;#34;, &amp;#34;[%#a]&amp;#34;}, {&amp;#34;% a&amp;#34;, &amp;#34;[% a]&amp;#34;}, {&amp;#34;%0a&amp;#34;, &amp;#34;[%0a]&amp;#34;}, {&amp;#34;%1.2a&amp;#34;, &amp;#34;[%1.2a]&amp;#34;}, {&amp;#34;%-1.2a&amp;#34;, &amp;#34;[%-1.2a]&amp;#34;}, {&amp;#34;%+1.2a&amp;#34;, &amp;#34;[%+1.2a]&amp;#34;}, {&amp;#34;%-+1.2a&amp;#34;, &amp;#34;[%+-1.2a]&amp;#34;}, {&amp;#34;%-+1.2abc&amp;#34;, &amp;#34;[%+-1.2a]bc&amp;#34;}, {&amp;#34;%-1.</description>
    </item>
    
  </channel>
</rss>